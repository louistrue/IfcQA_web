import * as THREE from "three";
export class FragmentMesh extends THREE.InstancedMesh {
    constructor(geometry, material, count, fragment) {
        super(geometry, material, count);
        if (!Array.isArray(material)) {
            material = [material];
        }
        this.material = material;
        if (!geometry.index) {
            throw new Error("The geometry for fragments must be indexed!");
        }
        this.geometry = geometry;
        this.fragment = fragment;
        const size = geometry.index.count;
        if (!geometry.groups.length) {
            geometry.groups.push({
                start: 0,
                count: size,
                materialIndex: 0,
            });
        }
    }
    exportData() {
        const position = this.geometry.attributes.position.array;
        const normal = this.geometry.attributes.normal.array;
        const index = Array.from(this.geometry.index.array);
        const groups = [];
        for (const group of this.geometry.groups) {
            const index = group.materialIndex || 0;
            const { start, count } = group;
            groups.push(start, count, index);
        }
        const materials = [];
        if (Array.isArray(this.material)) {
            for (const material of this.material) {
                const opacity = material.opacity;
                const transparent = material.transparent ? 1 : 0;
                const color = new THREE.Color(material.color).toArray();
                materials.push(opacity, transparent, ...color);
            }
        }
        const matrices = Array.from(this.instanceMatrix.array);
        let colors;
        if (this.instanceColor !== null) {
            colors = Array.from(this.instanceColor.array);
        }
        else {
            colors = [];
        }
        return {
            position,
            normal,
            index,
            groups,
            materials,
            matrices,
            colors,
        };
    }
}
//# sourceMappingURL=fragment-mesh.js.map