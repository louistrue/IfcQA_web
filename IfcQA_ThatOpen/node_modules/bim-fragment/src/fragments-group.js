import * as THREE from "three";
import { unzip } from "unzipit";
// TODO: Document this
export class FragmentsGroup extends THREE.Group {
    constructor() {
        super(...arguments);
        this.items = [];
        this.boundingBox = new THREE.Box3();
        this.coordinationMatrix = new THREE.Matrix4();
        // Keys are uints mapped with fragmentIDs to save memory
        this.keyFragments = new Map();
        // Map<expressID, [keys, rels]>
        // keys = fragmentKeys to which this asset belongs
        // rels = [floor, categoryid]
        this.data = new Map();
        // [geometryID, key]
        this.geometryIDs = {
            opaque: new Map(),
            transparent: new Map(),
        };
        this.ifcMetadata = {
            name: "",
            description: "",
            schema: "IFC2X3",
            maxExpressID: 0,
        };
        this.streamSettings = {
            baseUrl: "",
            baseFileName: "",
            ids: new Map(),
            types: new Map(),
        };
    }
    get hasProperties() {
        const hasLocalProps = this._properties !== undefined;
        const hasStreamProps = this.streamSettings.ids.size !== 0;
        return hasLocalProps || hasStreamProps;
    }
    getFragmentMap(expressIDs) {
        const fragmentMap = {};
        for (const expressID of expressIDs) {
            const data = this.data.get(expressID);
            if (!data)
                continue;
            for (const key of data[0]) {
                const fragmentID = this.keyFragments.get(key);
                if (fragmentID === undefined)
                    continue;
                if (!fragmentMap[fragmentID]) {
                    fragmentMap[fragmentID] = new Set();
                }
                fragmentMap[fragmentID].add(expressID);
            }
        }
        return fragmentMap;
    }
    dispose(disposeResources = true) {
        for (const fragment of this.items) {
            fragment.dispose(disposeResources);
        }
        this.coordinationMatrix = new THREE.Matrix4();
        this.keyFragments.clear();
        this.data.clear();
        this._properties = {};
        this.removeFromParent();
        this.items = [];
        this.ifcCivil = undefined;
    }
    setLocalProperties(properties) {
        this._properties = properties;
    }
    getLocalProperties() {
        return this._properties;
    }
    getAllPropertiesIDs() {
        if (this._properties) {
            return Object.keys(this._properties).map((id) => parseInt(id, 10));
        }
        return Array.from(this.streamSettings.ids.keys());
    }
    getAllPropertiesTypes() {
        if (this._properties) {
            const types = new Set();
            for (const id in this._properties) {
                const property = this._properties[id];
                if (property.type !== undefined) {
                    types.add(property.type);
                }
            }
            return Array.from(types);
        }
        return Array.from(this.streamSettings.types.keys());
    }
    async getProperties(id) {
        if (this._properties) {
            return this._properties[id] || null;
        }
        const url = this.getPropsURL(id);
        const data = await this.getPropertiesData(url);
        return data ? data[id] : null;
    }
    async setProperties(id, value) {
        if (this._properties) {
            if (value !== null) {
                this._properties[id] = value;
            }
            else {
                delete this._properties[id];
            }
            return;
        }
        // TODO: Fix this
        const url = this.getPropsURL(id);
        const data = await this.getPropertiesData(url);
        if (value !== null) {
            data[id] = value;
        }
        else {
            delete data[id];
        }
        // TODO: Finish defining this
        const formData = new FormData();
        formData.append("file", JSON.stringify(data));
        await fetch("api/KJAKDSJFAKÑSDFJAÑSFJDAÑJFÑA", {
            body: formData,
            method: "post",
        });
    }
    async getAllPropertiesOfType(type) {
        if (this._properties) {
            const result = {};
            let found = false;
            for (const id in this._properties) {
                const item = this._properties[id];
                if (item.type === type) {
                    result[item.expressID] = item;
                    found = true;
                }
            }
            return found ? result : null;
        }
        const { types } = this.streamSettings;
        const fileIDs = types.get(type);
        if (fileIDs === undefined) {
            return null;
        }
        const result = {};
        for (const fileID of fileIDs) {
            const name = this.constructFileName(fileID);
            const url = this.constructURL(name);
            const data = await this.getPropertiesData(url);
            for (const key in data) {
                result[parseInt(key, 10)] = data[key];
            }
        }
        return result;
    }
    getPropsURL(id) {
        const { ids } = this.streamSettings;
        const fileID = ids.get(id);
        if (fileID === undefined) {
            throw new Error("ID not found");
        }
        const name = this.constructFileName(fileID);
        return this.constructURL(name);
    }
    async getPropertiesData(url) {
        const fetched = await fetch(url);
        const buffer = await fetched.arrayBuffer();
        const file = new File([new Blob([buffer])], "temp");
        const fileURL = URL.createObjectURL(file);
        const { entries } = await unzip(fileURL);
        const name = Object.keys(entries)[0];
        return entries[name].json();
    }
    constructFileName(fileID) {
        const { baseFileName } = this.streamSettings;
        return `${baseFileName}-${fileID}`;
    }
    constructURL(name) {
        const { baseUrl } = this.streamSettings;
        return `${baseUrl}${name}`;
    }
}
//# sourceMappingURL=fragments-group.js.map